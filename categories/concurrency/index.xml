<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>concurrency on eBPF - the Super Power for Kernel</title><link>http://ebpf.xyz/categories/concurrency/</link><description>Recent content in concurrency on eBPF - the Super Power for Kernel</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Mon, 28 Mar 2022 23:16:30 +0800</lastBuildDate><atom:link href="http://ebpf.xyz/categories/concurrency/index.xml" rel="self" type="application/rss+xml"/><item><title>Concurrency Management in BPF</title><link>http://ebpf.xyz/post/concurrency-management-in-bpf/</link><pubDate>Mon, 28 Mar 2022 23:16:30 +0800</pubDate><guid>http://ebpf.xyz/post/concurrency-management-in-bpf/</guid><description>Addrï¼šhttps://ebpf.xyz/post/concurrency-management-in-bpf
In the beginning, programs run on the in-kernel BPF virtual machine had no persistent internal state and no data that was shared with any other part of the system. The arrival of eBPF and, in particular, its maps functionality, has changed that situation, though, since a map can be shared between two or more BPF programs as well as with processes running in user space. That sharing naturally leads to concurrency problems, so the BPF developers have found themselves needing to add primitives to manage concurrency (the &amp;ldquo;exchange and add&amp;rdquo; or XADD instruction, for example).</description></item></channel></rss>