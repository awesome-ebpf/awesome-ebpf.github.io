<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on eBPF - the Super Power for Kernel</title><link>http://ebpf.xyz/post/</link><description>Recent content in Posts on eBPF - the Super Power for Kernel</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Fri, 01 Apr 2022 23:12:04 +0800</lastBuildDate><atom:link href="http://ebpf.xyz/post/index.xml" rel="self" type="application/rss+xml"/><item><title>What is eBPF? | An Introduction and Practical Tips</title><link>http://ebpf.xyz/post/an_introduction_and_practical_tips/</link><pubDate>Fri, 01 Apr 2022 23:12:04 +0800</pubDate><guid>http://ebpf.xyz/post/an_introduction_and_practical_tips/</guid><description>Addr：https://ebpf.xyz/post/an_introduction_and_practical_tips
March 23, 2022
This article introduces developers to eBPF and explains how it can be used to add security, networking, and other capabilities in the Linux kernel space.
In Linux architecture, memory is separated into kernel space and user space. The kernel space is used to run the core kernel code and the device drivers. Processes running in kernel space have unrestricted access to all hardware, including CPU, memory, and disks.</description></item><item><title>Using eBPF To Enhance Kubernetes Monitoring: Powerful Insights</title><link>http://ebpf.xyz/post/ebpf_k8s_monitoring/</link><pubDate>Fri, 01 Apr 2022 23:02:58 +0800</pubDate><guid>http://ebpf.xyz/post/ebpf_k8s_monitoring/</guid><description>Addr：https://ebpf.xyz/post/ebpf_k8s_monitoring
March 23, 2022
eBPF is a piece of advanced Linux functionality that has been gradually put to use in Kubernetes over the last few years. In this guide, you will walk the reader through some use-cases for eBPF in Kubernetes, such as kernel-level network monitoring.
The Linux operating system divides its memory into two different spaces: the kernel and the userspace. The kernel space contains the core of the operating system and has access to device drivers and system hardware.</description></item><item><title>Build Useful Tools With Ebpf Part2 Tracing_the Locks in Linux Kernel</title><link>http://ebpf.xyz/post/build-useful-tools-with-ebpf-part2-tracing_the-locks-in-linux-kernel/</link><pubDate>Tue, 29 Mar 2022 00:25:47 +0800</pubDate><guid>http://ebpf.xyz/post/build-useful-tools-with-ebpf-part2-tracing_the-locks-in-linux-kernel/</guid><description>Addr：https://ebpf.xyz/post/build-useful-tools-with-ebpf-part2-tracing_the-locks-in-Linux-kernel
Linux kernel has different types of locks for synchronization. Spin locks, Semaphores, Futexes are some examples. These locks have different behavior and if they are not used properly, it can create performance degradation. For example, spinlocks have least locking and unlocking times but they waste CPU cycles. Spinlocks are used when the waiting time is known to be small. But if a kernel thread is waiting for a spinlock for a considerable amount of time, CPU time is wasted and system performance will be severely affected.</description></item><item><title>Build Useful Tools With Ebpf Part1 Setup Bcc</title><link>http://ebpf.xyz/post/build-useful-tools-with-ebpf-part1-setup-bcc/</link><pubDate>Tue, 29 Mar 2022 00:23:13 +0800</pubDate><guid>http://ebpf.xyz/post/build-useful-tools-with-ebpf-part1-setup-bcc/</guid><description>Addr：https://ebpf.xyz/post/build-useful-tools-with-ebpf-part1-setup-bc</description></item><item><title>Klock Stat</title><link>http://ebpf.xyz/post/klock-stat/</link><pubDate>Tue, 29 Mar 2022 00:13:09 +0800</pubDate><guid>http://ebpf.xyz/post/klock-stat/</guid><description>Addr：https://ebpf.xyz/post/klock-stat
kLockStat: An eBPF Tool To Monitor Linux Kernel Lock Contentions APRIL 30, 2019
Today most of the applications are multithreaded. Parallelism improves performance of applications. But there can be scalability bottlenecks inside the kernel. There are studies that exposes such bottlenecks in linux kernel. Even if the application is written in a perfectly scalable fasion, sometimes the bottlenecks inside the kernel prevent the application from scaling to a large number of processors.</description></item><item><title>Performanc Tracing with BPF</title><link>http://ebpf.xyz/post/performanc_tracing_with_bpf/</link><pubDate>Mon, 28 Mar 2022 23:36:04 +0800</pubDate><guid>http://ebpf.xyz/post/performanc_tracing_with_bpf/</guid><description>Addr：https://ebpf.xyz/post/performanc_tracing_with_bpf
#the-canvas { border: 1px solid black; direction: ltr; width: 100%; height: auto; display: none; } #paginator { display: none; text-align: center; margin-bottom: 10px; } #loadingWrapper { display: none; justify-content: center; align-items: center; width: 100%; height: 350px; } #loading { display: inline-block; width: 50px; height: 50px; border: 3px solid #d2d0d0;; border-radius: 50%; border-top-color: #383838; animation: spin 1s ease-in-out infinite; -webkit-animation: spin 1s ease-in-out infinite; } @keyframes spin { to { -webkit-transform: rotate(360deg); } } @-webkit-keyframes spin { to { -webkit-transform: rotate(360deg); } } Previous Next &amp;nbsp; &amp;nbsp; Page: / window.</description></item><item><title>Concurrency Management in BPF</title><link>http://ebpf.xyz/post/concurrency-management-in-bpf/</link><pubDate>Mon, 28 Mar 2022 23:16:30 +0800</pubDate><guid>http://ebpf.xyz/post/concurrency-management-in-bpf/</guid><description>Addr：https://ebpf.xyz/post/concurrency-management-in-bpf
In the beginning, programs run on the in-kernel BPF virtual machine had no persistent internal state and no data that was shared with any other part of the system. The arrival of eBPF and, in particular, its maps functionality, has changed that situation, though, since a map can be shared between two or more BPF programs as well as with processes running in user space. That sharing naturally leads to concurrency problems, so the BPF developers have found themselves needing to add primitives to manage concurrency (the &amp;ldquo;exchange and add&amp;rdquo; or XADD instruction, for example).</description></item><item><title>Dive into BPF: a list of reading material</title><link>http://ebpf.xyz/post/dive_into_ebpf_read_list/</link><pubDate>Sat, 26 Mar 2022 11:25:58 +0800</pubDate><guid>http://ebpf.xyz/post/dive_into_ebpf_read_list/</guid><description>Addr：https://ebpf.xyz/post/dive_into_ebpf_read_list
~ Updated 2019-01-10 ~
Chinese: https://linux.cn/article-9507-1.html (older 2017)
1. What is BPF? BPF, as in Berkeley Packet Filter, was initially conceived in 1992 so as to provide a way to filter packets and to avoid useless packet copies from kernel to userspace. It initially consisted in a simple bytecode that is injected from userspace into the kernel, where it is checked by a verifier—to prevent kernel crashes or security issues—and attached to a socket, then run on each received packet.</description></item><item><title>Awesome eBPF</title><link>http://ebpf.xyz/post/awesome-ebpf/</link><pubDate>Sat, 26 Mar 2022 11:17:01 +0800</pubDate><guid>http://ebpf.xyz/post/awesome-ebpf/</guid><description>Addr：https://ebpf.xyz/post/awesome-ebpf
A curated list of awesome projects related to eBPF.
BPF, as in Berkeley Packet Filter, is an in-kernel virtual machine running programs passed from user space. Initially implemented on BSD, then Linux, the (now legacy) &amp;ldquo;classic BPF&amp;rdquo; or cBPF machine would be used with tools like tcpdump for filtering packets in the kernel to avoid useless copies to user space. More recently, the BPF infrastructure in Linux has been completely reworked and gave life to the &amp;ldquo;extended BPF&amp;rdquo;, or eBPF, which gained new features (safety and termination checks, JIT-compiling for programs, persistent maps, a standard library, hardware offload support, etc.</description></item><item><title>What is eBPF?</title><link>http://ebpf.xyz/post/what_is_ebpf/</link><pubDate>Fri, 25 Mar 2022 23:34:17 +0800</pubDate><guid>http://ebpf.xyz/post/what_is_ebpf/</guid><description>Addr: https://awesome-ebpf.github.io//what_is_ebpf
1. What is eBPF? eBPF is a revolutionary technology with origins in the Linux kernel that can run sandboxed programs in an operating system kernel. It is used to safely and efficiently extend the capabilities of the kernel without requiring to change kernel source code or load kernel modules.
Historically, the operating system has always been an ideal place to implement observability, security, and networking functionality due to the kernel’s privileged ability to oversee and control the entire system.</description></item></channel></rss>